# 重构方案：采用 ECharts 风格的单包架构与代码复用优化

您提出的担忧非常专业。目前的 `build-sub-packages.js` 脚本确实存在致命缺陷：**代码重复**。每个子包（如 `@hudx/chart-bar`）都打包了一份 `Chart` 基类和 `utils`，这会导致项目体积膨胀，甚至引发 `instanceof` 检查失败等运行时错误。

为了达到“成熟、完善”的标准（参考 ECharts/MUI/AntD），我们建议放弃“物理拆分多个 npm 包”的执念，转而采用**逻辑拆分（Tree-shaking）**；或者，如果您必须物理拆分，则必须先进行架构重构。

考虑到您提到“参考 ECharts”，ECharts 采用的是 **单包架构 (Single Package)**，通过 `exports` 导出不同路径来实现按需引用。这是最推荐的现代化方案。

以下是两种成熟方案的对比与实施计划：

## 方案 A：ECharts 风格单包架构（强烈推荐）

这是目前业界主流（ECharts, MUI, Ant Design）的做法。

* **发布方式**：只发布一个 `hudx-charts` 包。
* **按需使用**：用户通过 `import { BarChart } from 'hudx-charts'` 或 `import { BarChart } from 'hudx-charts/bar'` 引用。
* **技术实现**：
  * 利用 ESM 的 Tree-shaking 特性，打包工具（Webpack/Vite）会自动剔除未使用的图表。
  * 配置 `package.json` 的 `exports` 字段暴露子路径。
  * **不需要** 维护几十个 `package.json`，不需要复杂的发包脚本。
* **优点**：架构最简单，维护成本最低，用户体验最好（版本统一），无代码重复风险。

## 方案 B：Monorepo 多包架构（如必须独立安装）

如果您坚持要求用户能 `npm install @hudx/chart-bar`，那么必须进行物理拆分。为了避免代码重复，必须将共享代码下沉。

### 实施步骤

1. **架构调整（下沉基类）**：
    * 将 `Chart.ts`（基类）、`types.ts` 和 `util/*` 从 `packages/charts` 移入 `packages/render`。
    * 这样 `BarChart` 和 `LineChart` 都可以从 `hudx-render` 引用基类，避免打包时重复包含。
2. **工作区重构**：
    * 废弃 `build-sub-packages.js` 脚本。
    * 在 `packages/` 下建立真正的独立子项目：
        * `packages/chart-bar` (依赖 `hudx-render`)
        * `packages/chart-line` (依赖 `hudx-render`)
    * 使用 `pnpm-workspace.yaml` 管理这些包。
3. **构建工具升级**：
    * 引入 **`tsup`** (基于 esbuild)。它是目前开发库最成熟的工具，零配置支持 CJS/ESM/DTS 打包，速度极快。
    * 不再为每个包写复杂的 vite 配置。

## 推荐行动计划

鉴于您提到“参考成熟完善的组件库”，我建议采用 **方案 A (ECharts 模式)** 的变体：**保留单包发布，但通过合理的 exports 配置达到完美的分离效果**。

但如果您明确需要**方案 B**（物理拆包），我将执行以下操作：

1. **移动文件**：将 `Chart.ts` 等公共逻辑移动到 `packages/render`。
2. **清理脚本**：删除 `build-sub-packages.js`。
3. **配置 Exports**：优化 `packages/charts` 的 `package.json`，使其完美支持 Tree-shaking 和子路径导入（如 `hudx-charts/bar`）。
4. *(可选)* 如果您一定需要 `@hudx/chart-bar` 这种独立包，我将为您设置 `tsup` 和独立目录结构，但这将显著增加项目复杂度。

**请确认：我们是否采用方案 A（ECharts 风格，单包 + 按需引用），这能解决所有代码重复和类型提示问题，且符合主流标准？**
（如果您确认，我将立即进行基类下沉和 Exports 优化）
